
<!DOCTYPE html >
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>
			Using GeoJSON
		</title>
		  <link rel="stylesheet" href="d3.slider.css" />  
		<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
		<script src="http://d3js.org/colorbrewer.v1.min.js"></script>
		<script src="d3.slider.js"></script>

		<style type="text/css">



		.brush .extent {
  		stroke: #000;
  		fill-opacity: .125;
 		shape-rendering: crispEdges;
		}

		div.tooltip {	
		    position: absolute;			
		    text-align: center;			
		    width: 80px;					
		    height: 40px;					
		    padding: 2px;				
		    font: 12px sans-serif;		
		    background: lightsteelblue;	
		    border: 0px;		
		    border-radius: 8px;			
		    pointer-events: none;			
		}

		/* Styling for the line charts 
			Adapted from Mike Bostock 
			http://bl.ocks.org/d3noob/8603837
		*/
			path { 
				stroke-width: 1;
				fill: none;
			}

/*			.axis path,
			.axis line {
				fill: none;
				stroke: grey;
				stroke-width: 1;
				shape-rendering: crispEdges;
			}*/			

		</style>
	</head>
	<body>
		<h1> Exploring ObamaCare </h1>
		 <div id="addPane">f

<body>

<select id= "races">
  
  <optgroup label="Race">
     <option value=0>All Races</option>
    <option value=1>Black</option>
    <option value=2>White not Hispanic</option>
     <option value=3>Hispanic not White</option>
  </optgroup>
</select>

  <select id = "income">
  
  <optgroup label="Income">
     <option value=0>All Income</option>
    <option value=1>1</option>
    <option value=2>2</option>
     <option value=3>3</option>
     <option value=4>4</option>
     <option value=5>5</option>
  </optgroup>

	</select>

<select id = "years">

	<optgroup label="Metrics" id="metrics"></optgroup>


</select>
     
 

  </div>

		<script type="text/javascript">

		// create an SVG region in the usual way

		/*TODO 	
			* Clean up global variables 
			* Remove print statements 
			* Styling 
			* Legends 
			* Clean up directory - get rid of unnecessary files 
			* Global min and global max 
		*/


		var width = 800, height = 500;


		var svg = d3.select("body")
				.append("svg")
				.attr({"width":width, "height":height});

		var visData, drawData, lineData, mapData, currentYear, currentRace, currentIncome, currentState, currentMetric, allData, raceData, incomeData, maxValue, minValue; 

		maxValue = 0; //defaults for max an min
		minValue  = 100 // defaults for 

		var years=["2006","2007","2008","2009","2010","2011","2012","2013"];
		var racelist=[0,1,2,3];
		var incomelist = [0,1,2,3,4,5]

		var statesNames = []; 
		// create a projection that provides our mapping from lat,lon data to x,y, coordiantes
		var projection = d3.geo.albersUsa()
				.translate([width/2, height/2]);

		// create a path tool that will translate GeoJSON into SVG path data
		var path = d3.geo.path().projection(projection);

		// create our coloring tool
		var color = d3.scale.quantize()
		.range(colorbrewer.YlGnBu[8]);

		// Define the div for the tooltip
		var div = d3.select("body").append("div")	
		    .attr("class", "tooltip")				
		    .style("opacity", 0);

		// the metric we are showing -- obviously, it would not take much to make this as interactive as the
		// first example

		// set the year and redraw map. 



			//d3.slider().axis(true).min(2000).max(2100).step(5)




		//set the new Year and redraw the Vis 
		function setYear(year){
			console.log("setYear got called! Year: ", year);
			currentYear = year;
			drawVis(); 
		}

		//set the new Race and redraw the Vis 
		function setRace(race){
			console.log("setRace got called! : ",race);
			currentRace = race;
			drawVis(); 
		}

		//set the new Income and redraw the Vis 
		function setIncome(income){
			//console.log("setRace got called! : ",race);
			currentIncome = income;
			drawVis(); 
		}

		if (currentYear === undefined){
			currentYear = "2006"; 
		}
		//current race default 
		if (currentRace === undefined){
			currentRace = 0; 

		//currentIncome default 
		}if (currentIncome === undefined){
			currentIncome = 0; 
		}		





		//draw the Visualization


		//sets up mapData for the general visualization with no categories 
		function visGeneral(){
				// build the popup menu

				var censusData = getNewStateData(); 


				//var censusData = drawData[currentYear]["states"];

				var censusMap = d3.map();
				censusData.forEach(function(d){censusMap.set(d.NAME,d)});

				// loop through all of the path data, attaching the appropriate
				// record to each one based on the name
				for (var i = 0; i < mapData.features.length; i++){
					var name = mapData.features[i].properties.name;
					mapData.features[i].properties.value = censusMap.get(name);
				}
			
			
		} 

		function getNewStateData(){
			var statesArray = [];
			var yearData = visData[currentYear];
			for (var state in yearData){
				var stateStr = String(state); 

				var PUI = yearData[stateStr][currentRace][currentIncome];
				var obj = {"NAME": stateStr, "PUI": PUI}
				statesArray.push(obj);
			}
	
			return statesArray; 

		} 


		//draw the map 
		function drawVis(){

				//set the color domain 
				drawData = allData; 

				//set the color domain 
				colorObject = d3.values(drawData); 

				// var max = d3.max(colorObject, function(yearData) {
		 	// 		 return d3.max(yearData["states"], function(d){ 
		 	// 		 	return +d["PUI"]; 
		 	// 		 });
				// });

				// var min = d3.min(colorObject, function(yearData) {
		 	// 		 return d3.min(yearData["states"], function(d){ 
		 	// 		 	return +d["PUI"]; 
		 	// 		 });
				// });

				//var max 

				color.domain([0, 50]);


				// call the visualtion for non specific data 

				visGeneral();

				//visRaces();

				// create the states in the SVG
				var states = svg.selectAll("path")
				.data(mapData.features); 

				states.exit()
					.transition()
					.duration(10)
					.remove(); 
				
				states.enter()
					.append("path")
					.attr("d", path)
					.attr("class","state");

				// style each state to set the fill color based on our metric
				states
					.style("fill", function(d){
					if (d.properties.value){
						return color(+d.properties.value["PUI"]);
					}	else{
						return "red";
					}

				})
			  .on("mouseover", function(d) {		
	            div.transition()		
	                .duration(200)		
	                .style("opacity", .9);		
	            div	.html(currentYear + "<br/>"  + d.properties.value["NAME"] + "<br/>"  + d.properties.value["PUI"].substring(0,4) +" %" )	//d.properties.value["PUI"].substring(0,4)
	                .style("left", (d3.event.pageX) + "px")		
	                .style("top", (d3.event.pageY - 28) + "px");	
	            })					
		        .on("mouseout", function(d) {		
		            div.transition()		
		                .duration(500)		
		                .style("opacity", 0);	
		        })
		        .on("click", function(d) {
		        	var clicked_state = d.properties.value["NAME"]; 
		        	console.log(clicked_state, "got clicked!");
		        	currentState = clicked_state;
		        	drawLineCharts();
		        }
		        );


		}

		/* Draws the line charts for the selected state 

			Adapted from Mike Bostock 
				http://bl.ocks.org/d3noob/8603837
		*/

 

		function drawLineCharts(){
			// currentState = "Alabama";
			currentMetric = "Race";
				var data = lineData[currentState][currentMetric]; 
				console.log(data);

				var width = 600; //600
		      	var height = 500; //600
		      	var margins = {top:60, bottom: 60, left: 60, right:60};
		     	var chartWidth = width - margins.left - margins.right;
		      	var chartHeight = height - margins.top - margins.bottom;
		      	var ymax = d3.max(data,function(d){return +d.PUI;});

		      	var ymax = d3.max(data, function(d){
		      		//console.log("d.vla ", d["values"]);


		      		return d3.max(d["values"], function (e){
		      				return e["PUI"];
		      			}
		      			);

		      	});
		      	console.log("ymax", ymax); 
	     		 //var xmax = d3.max(data,function(d){return +d.year;});
	     		 var xmax = d3.max(data, function(d){
		      		//console.log("d.vla ", d["values"]);


		      		return d3.max(d["values"], function (e){
		      				return e["year"];
		      			}
		      			);

		      	});
	     		 var ymin = d3.min(data, function(d){
		      		//console.log("d.vla ", d["values"]);


		      		return d3.min(d["values"], function (e){
		      				return e["PUI"];
		      			}
		      			);

		      	});
		      	console.log("ymax", ymax); 
	     		 //var xmax = d3.max(data,function(d){return +d.year;});
	     		 var xmin = d3.min(data, function(d){
		      		//console.log("d.vla ", d["values"]);


		      		return d3.min(d["values"], function (e){
		      				return e["year"];
		      			}
		      			);

		      	});
	     		 
	      		var xScale = d3.scale.linear().range([0,chartWidth],.1).nice().domain([xmin,xmax]);
	      		var yScale = d3.scale.linear().range([chartHeight, 0]).nice().domain([10,ymax]);
	      		var lineColor = d3.scale.ordinal()
						  .domain(1,5)
						  .range([ "rgb(153, 107, 195)", "rgb(56, 106, 197)", "rgb(93, 199, 76)", "rgb(223, 199, 31)", "rgb(234, 118, 47)"]);



				 var line = d3.svg.line()
				 		.defined(function(d){return d.PUI;})
					      .x(function(d) { 


					       return xScale(+d.year); })
					      .y(function(d) { 
					      	// var yVal = d.PUI;
					      	// if(yVal === undefined){
					      	// 	return 0; 
					      	// } 
					      	console.log("d for y in line", d.PUI);return yScale(+d.PUI); });



				
				// if (!clicked){

						d3.select('body').selectAll('.linesvg').remove();

						 var svg = d3.select('body')
							      .append('svg')
							      .classed("linesvg", true)
							      .attr({
							        width:width,
							        height:height
							      });

						  svg.selectAll("g").remove();
						
					      var chart = svg.append("g")
					      .attr("transform","translate("+margins.left + "," + margins.top + ")");


					      var xAxis = d3.svg.axis()
					      .scale(xScale)
					      .orient("bottom");


					      chart.append("g")
						      .attr("class","axis")
						      .attr("transform", "translate(0, " + chartHeight+")")
						      .call(xAxis)
						      .append("text")
						      .attr({
						        "x":chartWidth/2,
						        "y":margins.bottom/2,
						              "text-anchor":"middle" // set so the (x,y) of the text is in the middle bottom
						            })
						      .text("year");

						var yAxis = d3.svg.axis()
						      .scale(yScale)
						      .orient("left")
						      .innerTickSize(-chartWidth)
						      .outerTickSize(0)
						      .tickPadding(10);

						      chart.append("g")
						      .attr("class","axis")
						      .call(yAxis)
						      .append("text")
						      .attr({
						        "x":-chartHeight/2,
						        "y":3 * -margins.left/4,
						        "text-anchor":"middle",
						        "transform" : "rotate(-90)"
						      })
						      .text("PUI");

						 data.forEach(function(d){
						 	//console.log("d.values" , d.values);

					        chart.append("path")

					        .datum(d.values)
					        .attr("class", "line")
					        .attr("d", line)
					        .style("stroke", function(d, i){  return lineColor(d.year)}); //function(d){return lineColor(d[0].year);}

					        //var ln=chart.selectAll(".line");

					      	//chart.exit().remove();
					        chart.selectAll('circle')
						      .data(d.values, function(e,i){ return e[i]})
						      .enter()
						      .append('circle')
						      .attr({
							        cx:function(d){console.log("d.year in cx", +d.year); return xScale(+d.year);},
							        cy:function(d){return yScale(+d.PUI);},
							        r:function(d){return 2;}
							      });


			    		  });

				// }
				// else{ //we are just updating here 

				// 	d3.select('body').selectAll('svg').selectAll("")



				// }






			}

			// var	margin = {top: 30, right: 40, bottom: 30, left: 50},
			// 	width = 600 - margin.left - margin.right,
			// 	height = 270 - margin.top - margin.bottom;




			// var	x = d3.scale.linear().range([0, width]);
			// //var 
			// var	y = d3.scale.linear().range([height, 0]);

			// var	xAxis = d3.svg.axis().scale(x)
			// 	.orient("bottom").ticks(8);

			// var	yAxis = d3.svg.axis().scale(y)
			// 	.orient("left");

			// var	valueline = d3.svg.line()
			// 	.x(function(d) { return x(d[0]); }) //year 
			// 	.y(function(d) { return y(d[1]); }); // PUI
				
			// var	valueline2 = d3.svg.line()
			// 	.x(function(d) { return x(d.date); })
			// 	.y(function(d) { return y(d.open); });







		// 	if (!clicked){

		// 		//the default - no state clicked 
		// 			console.log("The default");

		// 			var	svg = d3.select("body")
		// 				.append("svg")
		// 					.attr("width", width + margin.left + margin.right)
		// 					.attr("height", height + margin.top + margin.bottom)
		// 				.append("g")
		// 					.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

		// 			// Get the data


		// 			// d3.csv("data2b.csv", function(error, data) {
		// 			// 	data.forEach(function(d) {
		// 			// 		d.date = parseDate(d.date);
		// 			// 		d.close = +d.close;
		// 			// 		d.open = +d.open;
		// 			// 	});



		// 				// Scale the range of the data
		// 				x.domain(d3.extent(data, function(d) { return d.date; }));
		// 				y.domain([0, d3.max(data, function(d) { return Math.max(d.close, d.open); })]);

		// 				//d3.selectAll("path").remove();c

		// 				//svg.selectAll("path").remove();

		// 				svg.append("path")		// Add the valueline path.
		// 					.attr("class", "line1")
		// 					.style("stroke", "steelblue")
		// 					.attr("d", valueline(data));

		// 				svg.append("path")		// Add the valueline2 path.
		// 					.attr("class", "line2")
		// 					.style("stroke", "red")
		// 					.attr("d", valueline2(data));

		// 				svg.append("g")			// Add the X Axis
		// 					.attr("class", "x axis")
		// 					.style("stroke", "black")
		// 					.attr("transform", "translate(0," + height + ")")
		// 					.call(xAxis);

		// 				svg.append("g")			// Add the Y Axis
		// 					.attr("class", "y axis")
		// 					.style("stroke", "black")
		// 					.call(yAxis);

		// 				svg.append("text")
		// 					.attr("transform", "translate(" + (width+3) + "," + y(data[0].open) + ")")
		// 					.attr("dy", ".35em")
		// 					.attr("text-anchor", "start")
		// 					.style("fill", "red")
		// 					.text("Open");

		// 				svg.append("text")
		// 					.attr("transform", "translate(" + (width+3) + "," + y(data[0].close) + ")")
		// 					.attr("dy", ".35em")
		// 					.attr("text-anchor", "start")
		// 					.style("fill", "steelblue")
		// 					.text("Close");


		// 			// 




		// 		});
		// 	}
		// 	if(clicked){
		// 		d3.csv("data-alt.csv", function(error, data) {
		// 	       	data.forEach(function(d) {
		// 		    	d.date = parseDate(d.date);
		// 		    	d.close = +d.close;
		// 		    });
		// 			var svg = d3.select("body").transition();

		// 			//make the changes 
		// 			svg.select(".line2")
		// 				.duration(750)
		// 				.attr("d", valueline2(data)); 
		// 		});

		// 	}

		// }






		// //Updates the line charts when a new state is clicked 
		function updateLineCharts(){
			console.log("updateLineCharts got called");
		    // Get the data again
		    d3.csv("data-alt.csv", function(error, data) {
		       	data.forEach(function(d) {
			    	d.date = parseDate(d.date);
			    	d.close = +d.close;
			    });
			var svg = d3.select("body").transition();

			//make the changes 
			svg.select(".line2")
				.duration(750)
				.attr("d", valueline2(data)); 

			});

		}

		// Helper function that returns the data needed to draw line chart 

	

		// Helper functions for creating the main JSON object //

		// gives us a data for a given year from the general data
		var getyeardata=function ( dataobj, year){
			//console.log("this function has been called");
			 var yeardata=[];
			dataobj.forEach(function(element){
				for (prop in element){
			//console.log(prop);
			if (prop==year){
				//console.log(year)
				yeardata.push(element[prop]);
				//console.log(ydata[0]);
			}
		}

			})
		
			
		return yeardata;
		};
		var getstatedata=function(datarray, state){
			var statedata=[];
			datarray.forEach(function(e){
				e.forEach(function(element){
					if (element[0]==state) {
					statedata.push(element)
				}
				})
				//console.log(element[0]);
				
			})
			return statedata;
		}

		var getraceData= function(datarray, race){
			var racedata=[]
			datarray.forEach(function(data){
				//console.log(data[1]);
				if (data[2]==race) {
					racedata.push(data);
				}
			})
			return racedata;
		}

		var getincomedata=function(datarray, income){
			  var value;
			 datarray.forEach(function(data){
			 	//console.log(data[4]);
			 	if (+data[4]==income) {
					value=data[5];
				}

			 })
			 
		return value;
		}



		// Function that creates our main Object // visData. 
		function createObject(dataset){

			var yearObj = {} //object for storing each year 
			years.forEach(function(year){
				var yearData = getyeardata(dataset, year);
				// yearObj[year] = yearArray; //just for testing 
				
				//get data for every state 
				var stateObj = {}
				statesNames.forEach(function(state){
					var stateData = getstatedata(yearData, state);

					//get data for all races 
					var raceObj = {}
					racelist.forEach(function(race){
						var raceData = getraceData(stateData, race);

						//get data for all incomes within each race 
						var incomeObj = {}
						incomelist.forEach(function(income){
							var incomeRaceData = getincomedata(raceData, income);
							incomeObj[income] = incomeRaceData; 

						});

						raceObj[race] = incomeObj; 
					}); 

					stateObj[state] = raceObj; 

				});

				yearObj[year] = stateObj; 

			}); 
			return yearObj; 
		}	


		function createLineData(myobj){
			function parser (obj){
				var newObj = {}; 
				statesNames.forEach(function(state){

					stateIncome = [];
					stateIncome["Income"] = [];
					stateIncome["Race"] = [];

					incomelist.forEach(function(income){
						//loop throught the years 
						var incValues = {};
						var raceValues = {};
						incValues["key"] = income; 
						incValues["values"] = [];
						incValsArray = [] 
						raceValues["values"] = []
						years.forEach(function(yr){
							var inc=obj[yr][state][0][income];

							var incobj = {"year": yr, "PUI": inc}; 
							incValues["values"].push(incobj); 
							// incValues["year"] = yr;
							// incValues["PUI"] = inc;
							// incValues["values"][]
							//incValues.push([yr, inc]); 

							if (income < 4){ //valid for getting race value 
						        raceValues["key"] = income
								var race = obj[yr][state][income][0] //get all races for 
								var raceobj = {"year": yr, "PUI": race};

								raceValues["values"].push(raceobj); 
							}

						});
						stateIncome["Income"].push(incValues);// = incValues;


						if (income < 4){ //Adding races which go till 4 
							stateIncome["Race"].push(raceValues); 
						}
						

					}); 

				newObj[state] = stateIncome; 

				});

				return newObj; 

			}

			return parser(myobj);

		}




		// fetch our data -- first the map, and then the CSV data (the order matters little here since we
		// are not displaying anything until the binding is done)
		d3.json("http://www.cs.middlebury.edu/~candrews/classes/infovis/data/us-states.json", 
			function(inputMapData){
			d3.json("race_new_Data.json", function(race_Data){
				//console.log(race_Data);
				raceData = race_Data; 
				//console.log("the following is the racedata");
				//console.log(race_Data);
			
				d3.json("income_data.txt", function (dataset) {


					//console.log(dataset[0][2006]);
					var array= dataset[0][2006];
					//d3.selectAll('#metrics').remove();
					for (var i = 1; i < 52; i++) {
						//console.log(array[i][0]);
						statesNames.push(array[i][0]);
					}

					visData = createObject(dataset); //create general object. 

					lineData = createLineData(visData); //create object for drawing line charts

					console.log( lineData["Alabama"]["Income"]);
					//console.log(myobj);
						
					allData = dataset;
					mapData = inputMapData; 

					//var states=Object.keys(dataset[0][0]);
					//console.log(dataset[0]["2006"]);
					var big={};
					//
					

					//console.log(statesNames);
					var o={};
					var racelist=[0,1,2,3];
					

					//console.log(o);
					

					//console.log(statesNames);

		
					//console.log(years);

					years.forEach(function (yr) {
						big [yr]=statesNames;
					})

					//console.log(big)


					var menu = d3.select("#metrics");
					
					years.forEach(function(d){
					 	//console.log(d);
						menu.append("option").attr("value",d).text(d);
					}); 

					drawVis(); 
					drawLineCharts(); 

					// set the behavior on a change to the menu (i.e., update the coloring)


					d3.select("#years").on("change", function () {
						//console.log("change happened!");
						console.log("this.value", this.value);
						setYear(this.value);
						});
					d3.select("#races").on("change", function () {
						console.log("change happened! :", this.value);

						setRace(this.value);
						});
					d3.select("#income").on("change", function () {
						console.log("change happened! :", this.value);

						setIncome(this.value);
						});

					//for the axis 
					// d3.select('#slider6').call(d3.slider().axis(true).min(2006).max(2013).step(1));
					// d3.slider().on("slide", function(evt, value) {
					//   d3.select('#slider6').text(value);
					// })

				    d3.select('#slider6').call(d3.slider().axis(true).min(2006).max(2013).step(1).on("slide", function(evt, value) {
				      d3.select('#slider6text').text(value);
				      setYear(value);
				    }));

					// create a map of our census data, so we can easily find records
					// correspondng to a particular stat
				});
			});
		});



		</script>

		

<div>

</div>

<div id= "slider6">
    
    <h2> Current Years <span id="slider6text">2006</span></h2>
    
    <div id="slider6"></div>

</div>


	</body>
</html>
