
<!DOCTYPE html >
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>
			Using GeoJSON
		</title>
		  <link rel="stylesheet" href="d3.slider.css" />  
		<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
		<script src="http://d3js.org/colorbrewer.v1.min.js"></script>
		<script src="d3.slider.js"></script>

		<style type="text/css">



		.brush .extent {
  		stroke: #000;
  		fill-opacity: .125;
 		shape-rendering: crispEdges;
		}

		div.tooltip {	
		    position: absolute;			
		    text-align: center;			
		    width: 80px;					
		    height: 40px;					
		    padding: 2px;				
		    font: 12px sans-serif;		
		    background: lightsteelblue;	
		    border: 0px;		
		    border-radius: 8px;			
		    pointer-events: none;			
		}

		/* Styling for the line charts 
			Adapted from Mike Bostock 
			http://bl.ocks.org/d3noob/8603837
		*/
			path { 
				stroke-width: 1;
				fill: none;
			}

/*			.axis path,
			.axis line {
				fill: none;
				stroke: grey;
				stroke-width: 1;
				shape-rendering: crispEdges;
			}*/			

		</style>
	</head>
	<body>
		<h1> Exploring ObamaCare </h1>
		 <div id="addPane">f

<body>

<select id= "races">
  
  <optgroup label="Race">
     <option value=0>All Races</option>
    <option value=1>Black</option>
    <option value=2>White not Hispanic</option>
     <option value=3>Hispanic not White</option>
  </optgroup>
</select>

  <select id = "income">
  
  <optgroup label="Income">
     <option value=0>All Income</option>
    <option value=1>1</option>
    <option value=2>2</option>
     <option value=3>3</option>
     <option value=4>4</option>
     <option value=5>5</option>
  </optgroup>

	</select>

<select id = "years">

	<optgroup label="Metrics" id="metrics"></optgroup>


</select>
     
 

  </div>

		<script type="text/javascript">

		// create an SVG region in the usual way
		var width = 800, height = 500;


		var svg = d3.select("body")
				.append("svg")
				.attr({"width":width, "height":height});

		var visData, drawData, mapData, currentYear, currentRace, currentIncome, allData, raceData, incomeData; 

		var years=["2006","2007","2008","2009","2010","2011","2012","2013"];
		var racelist=[0,1,2,3];
		var incomelist = [0,1,2,3,4,5]

		var statesNames = []; 
		// create a projection that provides our mapping from lat,lon data to x,y, coordiantes
		var projection = d3.geo.albersUsa()
				.translate([width/2, height/2]);

		// create a path tool that will translate GeoJSON into SVG path data
		var path = d3.geo.path().projection(projection);

		// create our coloring tool
		var color = d3.scale.quantize()
		.range(colorbrewer.YlGnBu[8]);

		// Define the div for the tooltip
		var div = d3.select("body").append("div")	
		    .attr("class", "tooltip")				
		    .style("opacity", 0);

		// the metric we are showing -- obviously, it would not take much to make this as interactive as the
		// first example

		// set the year and redraw map. 



			//d3.slider().axis(true).min(2000).max(2100).step(5)




		//set the new Year and redraw the Vis 
		function setYear(year){
			console.log("setYear got called! Year: ", year);
			currentYear = year;
			drawVis(); 
		}

		//set the new Race and redraw the Vis 
		function setRace(race){
			console.log("setRace got called! : ",race);
			currentRace = race;
			drawVis(); 
		}

		//set the new Income and redraw the Vis 
		function setIncome(income){
			//console.log("setRace got called! : ",race);
			currentIncome = income;
			drawVis(); 
		}

		if (currentYear === undefined){
			currentYear = "2006"; 
		}
		//current race default 
		if (currentRace === undefined){
			currentRace = 0; 

		//currentIncome default 
		}if (currentIncome === undefined){
			currentIncome = 0; 
		}		





		//draw the Visualization


		//sets up mapData for the general visualization with no categories 
		function visGeneral(){
				// build the popup menu

				var censusData = getNewStateData(); 


				//var censusData = drawData[currentYear]["states"];

				var censusMap = d3.map();
				censusData.forEach(function(d){censusMap.set(d.NAME,d)});

				// loop through all of the path data, attaching the appropriate
				// record to each one based on the name
				for (var i = 0; i < mapData.features.length; i++){
					var name = mapData.features[i].properties.name;
					mapData.features[i].properties.value = censusMap.get(name);
				}
			
			
		} 

		function getNewStateData(){
			var statesArray = [];
			var yearData = visData[currentYear];
			for (var state in yearData){
				var stateStr = String(state); 

				var PUI = yearData[stateStr][currentRace][currentIncome];
				var obj = {"NAME": stateStr, "PUI": PUI}
				statesArray.push(obj);
			}
	
			return statesArray; 

		} 


		//draw the map 
		function drawVis(){

				//set the color domain 
				drawData = allData; 

				//set the color domain 
				colorObject = d3.values(drawData); 

				// var max = d3.max(colorObject, function(yearData) {
		 	// 		 return d3.max(yearData["states"], function(d){ 
		 	// 		 	return +d["PUI"]; 
		 	// 		 });
				// });

				// var min = d3.min(colorObject, function(yearData) {
		 	// 		 return d3.min(yearData["states"], function(d){ 
		 	// 		 	return +d["PUI"]; 
		 	// 		 });
				// });

				color.domain([0, 50]);


				// call the visualtion for non specific data 

				visGeneral();

				//visRaces();

				// create the states in the SVG
				var states = svg.selectAll("path")
				.data(mapData.features); 

				states.exit()
					.transition()
					.duration(10)
					.remove(); 
				
				states.enter()
					.append("path")
					.attr("d", path)
					.attr("class","state");

				// style each state to set the fill color based on our metric
				states
					.style("fill", function(d){
					if (d.properties.value){
						return color(+d.properties.value["PUI"]);
					}	else{
						return "red";
					}

				})
			  .on("mouseover", function(d) {		
	            div.transition()		
	                .duration(200)		
	                .style("opacity", .9);		
	            div	.html(currentYear + "<br/>"  + d.properties.value["NAME"] + "<br/>"  + d.properties.value["PUI"].substring(0,4) +" %" )	//d.properties.value["PUI"].substring(0,4)
	                .style("left", (d3.event.pageX) + "px")		
	                .style("top", (d3.event.pageY - 28) + "px");	
	            })					
		        .on("mouseout", function(d) {		
		            div.transition()		
		                .duration(500)		
		                .style("opacity", 0);	
		        })
		        .on("click", function(d) {
		        	var clicked_state = d.properties.value["NAME"]; 
		        	console.log(clicked_state, "got clicked!");
		        	drawLineCharts(clicked_state);
		        }
		        );


		}

		/* Draws the line charts for the selected state 

			Adapted from Mike Bostock 
				http://bl.ocks.org/d3noob/8603837
		*/

 




		function drawLineCharts(clicked){
			var	margin = {top: 30, right: 40, bottom: 30, left: 50},
				width = 600 - margin.left - margin.right,
				height = 270 - margin.top - margin.bottom;

			var	parseDate = d3.time.format("%d-%b-%y").parse;

			var	x = d3.time.scale().range([0, width]);
			var	y = d3.scale.linear().range([height, 0]);

			var	xAxis = d3.svg.axis().scale(x)
				.orient("bottom").ticks(5);

			var	yAxis = d3.svg.axis().scale(y)
				.orient("left").ticks(5);

			var	valueline = d3.svg.line()
				.x(function(d) { return x(d.date); })
				.y(function(d) { return y(d.close); });
				
			var	valueline2 = d3.svg.line()
				.x(function(d) { return x(d.date); })
				.y(function(d) { return y(d.open); });


			if (!clicked){

				//the default - no state clicked 
					console.log("The default");
					var	svg = d3.select("body")
						.append("svg")
							.attr("width", width + margin.left + margin.right)
							.attr("height", height + margin.top + margin.bottom)
						.append("g")
							.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

					// Get the data


					d3.csv("data2b.csv", function(error, data) {
						data.forEach(function(d) {
							d.date = parseDate(d.date);
							d.close = +d.close;
							d.open = +d.open;
						});



						// Scale the range of the data
						x.domain(d3.extent(data, function(d) { return d.date; }));
						y.domain([0, d3.max(data, function(d) { return Math.max(d.close, d.open); })]);

						//d3.selectAll("path").remove();

						//svg.selectAll("path").remove();

						svg.append("path")		// Add the valueline path.
							.attr("class", "line1")
							.style("stroke", "steelblue")
							.attr("d", valueline(data));

						svg.append("path")		// Add the valueline2 path.
							.attr("class", "line2")
							.style("stroke", "red")
							.attr("d", valueline2(data));

						svg.append("g")			// Add the X Axis
							.attr("class", "x axis")
							.style("stroke", "black")
							.attr("transform", "translate(0," + height + ")")
							.call(xAxis);

						svg.append("g")			// Add the Y Axis
							.attr("class", "y axis")
							.style("stroke", "black")
							.call(yAxis);

						svg.append("text")
							.attr("transform", "translate(" + (width+3) + "," + y(data[0].open) + ")")
							.attr("dy", ".35em")
							.attr("text-anchor", "start")
							.style("fill", "red")
							.text("Open");

						svg.append("text")
							.attr("transform", "translate(" + (width+3) + "," + y(data[0].close) + ")")
							.attr("dy", ".35em")
							.attr("text-anchor", "start")
							.style("fill", "steelblue")
							.text("Close");


					console.log(data.length-1);
					console.log(data[data.length-1].open);
					console.log(data[0].open);
					console.log(y(data[0].open));
					console.log(y(data[0].close));

				});
			}
			if(clicked){
				d3.csv("data-alt.csv", function(error, data) {
			       	data.forEach(function(d) {
				    	d.date = parseDate(d.date);
				    	d.close = +d.close;
				    });
					var svg = d3.select("body").transition();

					//make the changes 
					svg.select(".line2")
						.duration(750)
						.attr("d", valueline2(data)); 
				});

			}

		}



		drawLineCharts(); 

		// //Updates the line charts when a new state is clicked 
		function updateLineCharts(){
			console.log("updateLineCharts got called");
		    // Get the data again
		    d3.csv("data-alt.csv", function(error, data) {
		       	data.forEach(function(d) {
			    	d.date = parseDate(d.date);
			    	d.close = +d.close;
			    });
			var svg = d3.select("body").transition();

			//make the changes 
			svg.select(".line2")
				.duration(750)
				.attr("d", valueline2(data)); 

			});

		}
	

		// Helper functions for creating the main JSON object //

		// gives us a data for a given year from the general data
		var getyeardata=function ( dataobj, year){
			//console.log("this function has been called");
			 var yeardata=[];
			dataobj.forEach(function(element){
				for (prop in element){
			//console.log(prop);
			if (prop==year){
				//console.log(year)
				yeardata.push(element[prop]);
				//console.log(ydata[0]);
			}
		}

			})
		
			
		return yeardata;
		};
		var getstatedata=function(datarray, state){
			var statedata=[];
			datarray.forEach(function(e){
				e.forEach(function(element){
					if (element[0]==state) {
					statedata.push(element)
				}
				})
				//console.log(element[0]);
				
			})
			return statedata;
		}

		var getraceData= function(datarray, race){
			var racedata=[]
			datarray.forEach(function(data){
				//console.log(data[1]);
				if (data[2]==race) {
					racedata.push(data);
				}
			})
			return racedata;
		}

		var getincomedata=function(datarray, income){
			  var value;
			 datarray.forEach(function(data){
			 	//console.log(data[4]);
			 	if (+data[4]==income) {
					value=data[5];
				}

			 })
			 
		return value;
		}



		// Function that creates our main Object // visData. 
		function createObject(dataset){

			var yearObj = {} //object for storing each year 
			years.forEach(function(year){
				var yearData = getyeardata(dataset, year);
				// yearObj[year] = yearArray; //just for testing 
				
				//get data for every state 
				var stateObj = {}
				statesNames.forEach(function(state){
					var stateData = getstatedata(yearData, state);

					//get data for all races 
					var raceObj = {}
					racelist.forEach(function(race){
						var raceData = getraceData(stateData, race);

						//get data for all incomes within each race 
						var incomeObj = {}
						incomelist.forEach(function(income){
							var incomeRaceData = getincomedata(raceData, income);
							incomeObj[income] = incomeRaceData; 

						});

						raceObj[race] = incomeObj; 
					}); 

					stateObj[state] = raceObj; 

				});

				yearObj[year] = stateObj; 

			}); 
			visData = yearObj; 
			//return yearObj; 
		}	

		function getLineData(){

			var lineData = []
		}


		// fetch our data -- first the map, and then the CSV data (the order matters little here since we
		// are not displaying anything until the binding is done)
		d3.json("http://www.cs.middlebury.edu/~candrews/classes/infovis/data/us-states.json", 
			function(inputMapData){
			d3.json("race_new_Data.json", function(race_Data){
				//console.log(race_Data);
				raceData = race_Data; 
				//console.log("the following is the racedata");
				//console.log(race_Data);
			
				d3.json("income_data.txt", function (dataset) {


					//console.log(dataset[0][2006]);
					var array= dataset[0][2006];
					//d3.selectAll('#metrics').remove();
					for (var i = 1; i < 52; i++) {
						//console.log(array[i][0]);
						statesNames.push(array[i][0]);
					}

					var myobj=	createObject(dataset);
					//console.log(myobj);
						
					allData = dataset;
					mapData = inputMapData; 

					//var states=Object.keys(dataset[0][0]);
					//console.log(dataset[0]["2006"]);
					var big={};
					//
					

					//console.log(statesNames);
					var o={};
					var racelist=[0,1,2,3];
					

					//console.log(o);
					

					//console.log(statesNames);

		
					//console.log(years);

					years.forEach(function (yr) {
						big [yr]=statesNames;
					})

					//console.log(big)


					var menu = d3.select("#metrics");
					
					years.forEach(function(d){
					 	//console.log(d);
						menu.append("option").attr("value",d).text(d);
					}); 

					drawVis(); 

					// set the behavior on a change to the menu (i.e., update the coloring)


					d3.select("#years").on("change", function () {
						//console.log("change happened!");
						console.log("this.value", this.value);
						setYear(this.value);
						});
					d3.select("#races").on("change", function () {
						console.log("change happened! :", this.value);

						setRace(this.value);
						});
					d3.select("#income").on("change", function () {
						console.log("change happened! :", this.value);

						setIncome(this.value);
						});

					//for the axis 
					// d3.select('#slider6').call(d3.slider().axis(true).min(2006).max(2013).step(1));
					// d3.slider().on("slide", function(evt, value) {
					//   d3.select('#slider6').text(value);
					// })

				    d3.select('#slider6').call(d3.slider().axis(true).min(2006).max(2013).step(1).on("slide", function(evt, value) {
				      d3.select('#slider6text').text(value);
				      setYear(value);
				    }));

					// create a map of our census data, so we can easily find records
					// correspondng to a particular stat
				});
			});
		});




		</script>

		

<div>

</div>

<div id= "slider6">
    
    <h2> Current Years <span id="slider6text">2006</span></h2>
    
    <div id="slider6"></div>

</div>


	</body>
</html>
